// src/daemon/src/GpuMonitor.AMD.cpp
#include "include/GpuMonitor.hpp"
#include "include/Log.hpp"
#include "include/Utils.hpp"

#ifdef LFC_WITH_AMDSMI
  // The wrapper header (amdsmi/amdsmi.h) is generated by CMake if the distro ships headers under amd_smi/amdsmi.h
  #include <amdsmi/amdsmi.h>
  #include <cstdio>
  #include <cstring>
  #include <vector>
  #include <optional>
  #include <string>
  #include <algorithm>
  #include <cinttypes>
#endif

namespace lfc {

#ifdef LFC_WITH_AMDSMI

// Compile-time helper to get the normalized PCI BDF string from GpuSample regardless of the member name.
template <typename T>
static std::string getPciBdf(const T& g) {
    if constexpr (requires { g.pci; }) {
        return g.pci;
    } else if constexpr (requires { g.pciBdf; }) {
        return g.pciBdf;
    } else {
        return std::string{};
    }
}

// Normalize AMD SMI 6.x BDF to "0000:bb:dd.f".
static std::string bdfToString(const amdsmi_bdf_t& b) {
    const unsigned dom = static_cast<unsigned>(b.domain_number);
    const unsigned bus = static_cast<unsigned>(b.bus_number);
    const unsigned dev = static_cast<unsigned>(b.device_number);
    const unsigned fun = static_cast<unsigned>(b.function_number);
    char out[32];
    std::snprintf(out, sizeof(out), "%04x:%02x:%02x.%1x", dom, bus, dev, fun);
    return std::string(out);
}

// Enumerate all processor handles across all sockets (AMDSMI 6.x API).
static std::vector<amdsmi_processor_handle> enumerateProcessors() {
    std::vector<amdsmi_processor_handle> out;

    uint32_t scount = 0;
    amdsmi_status_t st = amdsmi_get_socket_handles(&scount, nullptr);
    if (st != AMDSMI_STATUS_SUCCESS || scount == 0) return out;

    std::vector<amdsmi_socket_handle> sockets(scount, nullptr);
    st = amdsmi_get_socket_handles(&scount, sockets.data());
    if (st != AMDSMI_STATUS_SUCCESS || scount == 0) return out;

    for (auto s : sockets) {
        uint32_t pcount = 0;
        st = amdsmi_get_processor_handles(s, &pcount, nullptr);
        if (st != AMDSMI_STATUS_SUCCESS || pcount == 0) continue;

        std::vector<amdsmi_processor_handle> procs(pcount, nullptr);
        st = amdsmi_get_processor_handles(s, &pcount, reinterpret_cast<void**>(procs.data()));
        if (st != AMDSMI_STATUS_SUCCESS || pcount == 0) continue;

        procs.resize(pcount);
        out.insert(out.end(), procs.begin(), procs.end());
    }
    return out;
}

// Find the AMD SMI processor handle by matching PCI BDF string.
static amdsmi_processor_handle findHandleByBdf(const std::vector<amdsmi_processor_handle>& handles,
                                               const std::string& wantPci)
{
    if (wantPci.empty()) return nullptr;
    for (auto h : handles) {
        amdsmi_bdf_t bdf{};
        if (amdsmi_get_gpu_device_bdf(h, &bdf) == AMDSMI_STATUS_SUCCESS) {
            if (bdfToString(bdf) == wantPci) return h;
        }
    }
    return nullptr;
}

// Read temperature in Â°C (API returns milli-Celsius).
static std::optional<double> readTempC(amdsmi_processor_handle h,
                                       amdsmi_temperature_type_t type,
                                       amdsmi_temperature_metric_t metric)
{
    int64_t milli_c = 0;
    amdsmi_status_t st = amdsmi_get_temp_metric(h, type, metric, &milli_c);
    if (st != AMDSMI_STATUS_SUCCESS) return std::nullopt;
    return static_cast<double>(milli_c) / 1000.0;
}

// Read fan RPM using the Fedora AMDSMI 6.3.x signature (single rpm per sensor index).
static std::optional<int> readFanRpm(amdsmi_processor_handle h) {
    // Try a few typical sensor indices and return the first positive RPM.
    for (uint32_t idx = 0; idx < 4; ++idx) {
        int64_t rpm = 0;
        amdsmi_status_t st = amdsmi_get_gpu_fan_rpms(h, idx, &rpm);
        if (st == AMDSMI_STATUS_SUCCESS && rpm > 0) {
            return static_cast<int>(rpm);
        }
    }
    return std::nullopt;
}

// Detect PWM capability by checking if percent-speed query succeeds (any sensor).
static bool hasPwmCapability(amdsmi_processor_handle h) {
    for (uint32_t idx = 0; idx < 4; ++idx) {
        int64_t speed = 0; // API expects int64_t*
        if (amdsmi_get_gpu_fan_speed(h, idx, &speed) == AMDSMI_STATUS_SUCCESS) {
            return true;
        }
    }
    return false;
}

#endif // LFC_WITH_AMDSMI

void GpuMonitor::enrichViaAMDSMI(std::vector<GpuSample>& out)
{
#ifndef LFC_WITH_AMDSMI
    (void)out;
    return;
#else
    amdsmi_status_t st = amdsmi_init(0);
    if (st != AMDSMI_STATUS_SUCCESS) {
        LOG_DEBUG("gpu: AMDSMI init failed (status=%d)", (int)st);
        return;
    }

    auto handles = enumerateProcessors();
    if (handles.empty()) {
        LOG_DEBUG("gpu: AMDSMI no processors found");
        (void)amdsmi_shut_down();
        return;
    }

    for (auto& g : out) {
        if (g.vendor != "AMD") continue;

        const std::string wantPci = getPciBdf(g);
        auto h = findHandleByBdf(handles, wantPci);
        if (!h) {
            LOG_DEBUG("gpu: AMDSMI no handle match for pci=%s", wantPci.c_str());
            continue;
        }

        // Temperatures: prefer SMI values but never overwrite values that are already present.
        if (!g.tempEdgeC.has_value()) {
            if (auto v = readTempC(h, AMDSMI_TEMPERATURE_TYPE_EDGE, AMDSMI_TEMP_CURRENT)) {
                g.tempEdgeC = *v;
            }
        }
        if (!g.tempHotspotC.has_value()) {
            if (auto v = readTempC(h, AMDSMI_TEMPERATURE_TYPE_JUNCTION, AMDSMI_TEMP_CURRENT)) {
                g.tempHotspotC = *v;
            }
        }
        // We keep tempMemoryC via hwmon fallback if SMI does not provide a dedicated enum on this distro.

        // Fan tachometer (RPM)
        if (!g.fanRpm.has_value()) {
            if (auto rpm = readFanRpm(h)) {
                g.fanRpm = *rpm;
                g.hasFanTach = true;
            }
        }

        // PWM capability
        if (!g.hasFanPwm) {
            g.hasFanPwm = hasPwmCapability(h);
        }

        LOG_DEBUG("gpu: AMDSMI enriched pci=%s edge=%.1fC hot=%.1fC mem=%.1fC rpm=%d pwmCap=%d",
                  wantPci.c_str(),
                  g.tempEdgeC.value_or(-1.0),
                  g.tempHotspotC.value_or(-1.0),
                  g.tempMemoryC.value_or(-1.0),
                  g.fanRpm.value_or(0),
                  g.hasFanPwm ? 1 : 0);
    }

    (void)amdsmi_shut_down();
#endif
}

} // namespace lfc
